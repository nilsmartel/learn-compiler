
// code
function sum(a, b) {
    return a + b
}

// asm
function sum
a
b
    tmp
add tmp, *a, *b
return tmp

---

// code
function abc(x) {
    return x*2 + 7
}

// asm
function abc
x
tmp
tmp2
mul add, $x, 2
add tmp2, *tmp, 7
return tmp2

---

function ifelse(b, n) {
    if b == true {
        return 8
    }

    return n
}

// asm
function ifelse
b
n
jumpif *a branch1
jump branch2
branch1:
    return 8
branch2:
    return *n

---

function ifelse(b, n) {
    let x = 0
    if b == true {
        let something = 7
        something += 1
        x += something
    } else {
        x += n
    }

    return x
}

// asm
function ifelse
b
n
x
jumpif *a branch1
jump branch2
branch1:
    something
    store something, 7
    add something, *something, 1
    add x, *x, something
    jump branch3
branch2:
    add x, *x, n
    jump branch3
branch3:
    return x

---

function nested(a, b) {
    if (a) {
        let c = 7
        if (b) {
            let n = 0
        }
    }

    return void
}

// Observation:
// a block may have different entry points, but it's scope does not differ

// asm
function nested
a
b
jumpif *a branch1
jump branchEnd      // Note how after jumpif there still _has_ to come _jump_ + ( jumpif* jump) can only appear at the very end of a block
branch1:
    c
    store c, 7
    jumpif *b branch2
    jump branch3
branch2:
    n
    store n, 0
    jump branch3
branch3:            // Empty branch, can be optimised quite easily
    jump branchEnd
branchEnd:
    return ()       // return void, empty tuple of bytes


---

function nested_return(a, b) {
    if (a) {
        let c = 7
        if (b) {
            return
        }
    }

    return void
}

// asm
function nested_return
a
b
jumpif *a branch1
jump branchEnd
branch1:
    c
    store c, 7
    jumpif *b branch2
    jump branch3
branch2:
    return              // how to implement return? Problems: Clear Scope
branch3:
    jump branchEnd
branchEnd:
    return ()

---
// different attempt. Scope levels

function x() {
    let a
    let b
    block {
        let x
        block {
            let y
            let z
        }
        let w
    }
    let v
}

// scopes
scope1: (a, b)
scope2: scope1 : (x)
scope3: scope2 : (y, z)
scope4: scope2 : (w)
scope5: scope1 : (v)
// Problem: Not clear, that the scopes form a tree graph
